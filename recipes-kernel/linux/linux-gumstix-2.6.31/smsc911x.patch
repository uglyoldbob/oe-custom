diff --git a/drivers/net/smsc911x.h b/drivers/net/smsc911x.h
index b5716bd..7f0f36f 100644
--- a/drivers/net/smsc911x.h
+++ b/drivers/net/smsc911x.h
@@ -23,7 +23,7 @@
 
 #define TX_FIFO_LOW_THRESHOLD	((u32)1600)
 #define SMSC911X_EEPROM_SIZE	((u32)7)
-#define USE_DEBUG		0
+#define USE_DEBUG		2
 
 /* This is the maximum number of packets to be received every
  * NAPI poll */
diff --git a/drivers/net/smsc911x.c b/drivers/net/smsc911x.c
index eb7db03..040a2ad 100644
--- a/drivers/net/smsc911x.c
+++ b/drivers/net/smsc911x.c
@@ -1168,7 +1181,7 @@ static int smsc911x_open(struct net_device *dev)
 		SMSC_WARNING(IFUP,
 			"Timed out waiting for EEPROM busy bit to clear");
 
-	smsc911x_reg_write(pdata, GPIO_CFG, 0x70070000);
+	smsc911x_reg_write(pdata, GPIO_CFG, GPIO_CFG_LED1_EN_ | GPIO_CFG_LED2_EN_ | (1 << 20));
 
 	/* The soft reset above cleared the device's MAC address,
 	 * restore it from local copy (set in probe) */
@@ -1180,8 +1193,8 @@ static int smsc911x_open(struct net_device *dev)
 	smsc911x_reg_write(pdata, INT_EN, 0);
 	smsc911x_reg_write(pdata, INT_STS, 0xFFFFFFFF);
 
-	/* Set interrupt deassertion to 100uS */
-	intcfg = ((10 << 24) | INT_CFG_IRQ_EN_);
+	/* Set interrupt deassertion to 22*10uS */
+	intcfg = ((22 << 24) | INT_CFG_IRQ_EN_);
 
 	if (pdata->config.irq_polarity) {
 		SMSC_TRACE(IFUP, "irq polarity: active high");
@@ -1207,8 +1220,9 @@ static int smsc911x_open(struct net_device *dev)
 	temp |= INT_EN_SW_INT_EN_;
 	smsc911x_reg_write(pdata, INT_EN, temp);
 
-	timeout = 1000;
+	timeout = 2000;
 	while (timeout--) {
+		//smp_rmb();
 		if (pdata->software_irq_signal)
 			break;
 		msleep(1);
@@ -1445,6 +1459,8 @@ static irqreturn_t smsc911x_irqhandler(int irq, void *dev_id)
 	int serviced = IRQ_NONE;
 	u32 temp;
 
+	//SMSC_TRACE(INTR, "Got an interrupt for smsc911x");
+
 	if (unlikely(intsts & inten & INT_STS_SW_INT_)) {
 		temp = smsc911x_reg_read(pdata, INT_EN);
 		temp &= (~INT_EN_SW_INT_EN_);
@@ -1934,6 +1951,39 @@ static int __devexit smsc911x_drv_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static inline unsigned int is_gumstix_oui(u8 *addr)
+{
+	return (addr[0] == 0x00 && addr[1] == 0x15 && addr[2] == 0xC9);
+}
+
+/**
+ * gen_serial_ether_addr - Generate software assigned Ethernet address
+ * based on the system_serial number
+ * @addr: Pointer to a six-byte array containing the Ethernet address
+ *
+ * Generate an Ethernet address (MAC) that is not multicast
+ * and has the local assigned bit set, keyed on the system_serial
+ */
+static inline void gen_serial_ether_addr(u8 *addr)
+{
+	static u8 ether_serial_digit = 0;
+	addr [0] = system_serial_high >> 8;
+	addr [1] = system_serial_high;
+	addr [2] = system_serial_low >> 24;
+	addr [3] = system_serial_low >> 16;
+	addr [4] = system_serial_low >> 8;
+	addr [5] = (system_serial_low & 0xc0) |	/* top bits are from system serial */
+		(1 << 4) |			/* 2 bits identify interface type 1=ether, 2=usb, 3&4 undef */
+		((ether_serial_digit++) & 0x0f);	/* 15 possible interfaces of each type */
+
+	if(!is_gumstix_oui(addr))
+	{
+		addr [0] &= 0xfe;		/* clear multicast bit */
+		addr [0] |= 0x02;		/* set local assignment bit (IEEE802) */
+	}
+}
+
+
 static int __devinit smsc911x_drv_probe(struct platform_device *pdev)
 {
 	struct net_device *dev;
@@ -2067,11 +2117,11 @@ static int __devinit smsc911x_drv_probe(struct platform_device *pdev)
 			SMSC_TRACE(PROBE,
 				"Mac Address is read from LAN911x EEPROM");
 		} else {
-			/* eeprom values are invalid, generate random MAC */
-			random_ether_addr(dev->dev_addr);
+			/* eeprom values are invalid, generate MAC from serial number */
+			gen_serial_ether_addr(dev->dev_addr);
 			smsc911x_set_hw_mac_address(pdata, dev->dev_addr);
 			SMSC_TRACE(PROBE,
-				"MAC Address is set to random_ether_addr");
+				"MAC Address is derived from system serial number");
 		}
 	}
 
diff --git a/include/linux/smsc911x.h b/include/linux/smsc911x.h
index b327250..ff46e9f 100644
--- a/include/linux/smsc911x.h
+++ b/include/linux/smsc911x.h
@@ -47,4 +47,15 @@ struct smsc911x_platform_config {
 #define SMSC911X_FORCE_EXTERNAL_PHY 		(BIT(3))
 #define SMSC911X_SAVE_MAC_ADDRESS		(BIT(4))
 
+/*
+ * SMSC911X_SWAP_FIFO:
+ * Enables software byte swap for fifo data. Should only be used as a
+ * "last resort" in the case of big endian mode on boards with incorrectly
+ * routed data bus to older devices such as LAN9118. Newer devices such as
+ * LAN9221 can handle this in hardware, there are registers to control
+ * this swapping but the driver doesn't currently use them.
+ */
+#define SMSC911X_SWAP_FIFO			(BIT(5))
+
 #endif /* __LINUX_SMSC911X_H__ */
+


